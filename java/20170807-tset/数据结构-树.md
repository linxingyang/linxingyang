# 树 #
## 1 基本概念 ##


### 1.1 树是n(n>=0)个结点的有限集 ###
 
- n=0时称为空树
- n!=0时
> ***有且仅有一个***特定的称为根(root)的结点
> 
> 当n>1时，其余节点可以分为m（m>0）个***互不相交***的有限集T1,T2,...,Tm，其中每个集合本身又是一棵树，并且称为根的子树（subtree）

### 1.2 度 ###
* **度**：节点拥有的子树数称为度
* **叶结点/终端结点**：度为0的结点
* **分支结点/非终端结点**：度不为0的结点，包括根结点
* **内部结点**：度不为0的结点，不包括根结点
* **树的度**：各结点中，度的最大的值就是树的度

### 1.3 结点间的关系 ###
* **孩子**：结点的子树
* **双亲**：结点的双亲
* **兄弟**：同一个双亲的孩子之间
* **祖先**：从根到该结点所经分支上的所有结点
* **子孙**：以某结点为根的子树中的任一结点都称为该结点的子孙
* **堂兄弟**：同一层的结点，但不是同个双亲的

### 1.4 层次 深度 有序/无序树 森林 ###
* **层次**：结点的层次从根开始定义，根为第一层，根的孩子为第二层
* **深度/高度**：树种最大层次就称为树的深度 
* **有序/无序树**：结点种的各子树从左到右是有次序的，不能互换的，则称该树为有序树，否则称无序树。
* **森林**：M（m>0）棵互不相交的树的集合


## 2 树的结构 数据类型 存储结构 ##

### 2.1 树结构 ###
* **根结点**：无双亲，唯一
* **叶结点**：无孩子，可以多个
* **中间结点**：一个双亲多个孩子

### 2.2 树操作 ###
* 清空树
* 返回树的深度
* 返回树的根结点
* 返回结点的值
* 给结点赋值
* 返回结点的双亲
* 返回结点的左孩子
* 返回结点的右兄弟
* 插入结点
* 删除节点

### 2.3 树的存储结构 ###


* 双亲表示法
> 找双亲 O1
> 找孩子 ON 
> 找兄弟 ON

* 孩子表示法
* 孩子兄弟表示法

这些结构都可以根据需求进行扩展



## 3 二叉树 ##

### 3.1 基本概念 ###
二叉树（Binary Tree） 是n(n>=0) 个结点的有限集合。该集合

- 或者为空集（称为空二叉树）。
- 或者由一个根结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成

### 3.2 特点 ###
* 每个结点最多有两个子树
* 左子树和右子树是有顺序的（就像人的左手和右手）
* 即使某个结点只有一颗树，也要区分它是左子树还是右子树

二叉树具有五种基本形态

* 空二叉树
* 只有一个根结点
* 根结点只有左子树
* 根结点只有右子树
* 根结点既有左子树又有右子树

### 3.3 特殊的二叉树 ###
* 斜树

> 左斜树：所有结点都只有左节点
> 
> 右斜树：所有结点都只有右结点 

* 满二叉树

> 所有结点都存在左子树和右子树，并且所有叶子节点都在同一层上。
>
> 特点：
> 
> * 叶子的结点只能出现在最下面一层
> * 分叶子结点的度一定是2
> * 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多

* 完全二叉树
> 就是按从上到下，从左到右的顺序数过去，1,2,3,4,5。。。 数到最后之前没有结点是空的。
>
> 特点：
> 
> * 叶子结点只能出现在最下面两层
> * 最下层的叶子一定集中在左部连续位置
> * 倒数二层，若有叶子结点，一定都在右部连续位置
> * 如果结点度为1，则该结点只有左海子，即不存在只有右孩子的情况
> * 同样结点数的二叉树，完全二叉树的深度最小


### 3.4 二叉树的性质 ###
* 在i层上至多有2<sup>i-1</sup>个结点
* 深度为K的二叉树至多有 2<sup>k</sup>-1个结点（k>=1）
* 任何一个二叉树 T，如果其叶子结点数为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1
> 推导过程，假设总结点数n，度为0,1,2的结点个数分别为：n<sub>0</sub>，n<sub>1</sub>，n<sub>2</sub>
> 那么 n = n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>

> n个点，就说明n-1条线，且满足关系 n-1=n<sub>1</sub> + 2n<sub>2</sub>

> 综合两个等式： n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub> -1 = n<sub>1</sub> + 2n<sub>2</sub>

> 化简后得到  n<sub>0</sub> = n<sub>2</sub> + 1

* 具有n个接点的完全二叉树的深度为 [log<sub>2</sub>n] + 1 向下取整，[x]表示不大于x的最大整数
* 对于一个有n个结点的完全二叉树，
> 1. 如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则结点的双亲是结点[i/2] (向下取整)
> 2. 如果2i>n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i
> 3. 如果2i+1>n，则结点i无右孩子；否则其右孩子是结点2i+1

### 3.5 二叉树的存储结构 ###
* 顺序存储
* 二叉链表


### 3.6 遍历二叉树 ###
二叉树的遍历：从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次

1. 前序遍历
2. 中序遍历
3. 后序遍历
4. 层序遍历

* 给定二叉树，用上面遍历方式得到顺序
* 给定遍历顺序，得到二叉树的结构
> * 给定前序遍历和中序遍历序列，可以唯一确定一棵二叉树
> * 给定后续遍历和中序遍历序列，可以唯一确定一棵二叉树
> * 给定前序遍历和后序遍历序列，不能唯一确定一棵二叉树
> 前序遍历结果：ABCDEF
> 
> 中序遍历结果：CBAEDF
> 
> 求后序遍历结果：

### 3.7 线索二叉树 ###
对二叉树以某种次序遍历使其变为线索二叉树的过程称作是线索化

如果所使用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉树的存储结构就是非常不错的选择。

### 3.8 树、森林与二叉树的转换 ###

* 树转二叉树
> 1. 加线：所有兄弟之间连线
> 2. 去线：只保留与长子（左孩子）的连线，去掉与其他孩子的连线
> 3. 旋转：左孩子作为左结点，兄弟作为右结点

* 森林转换为二叉树
> 1. 把每棵树转换为二叉树
> 2. 第一颗二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连起来。

* 二叉树转树。树转二叉树的逆过程
> 1. 加线：如果一个结点有左孩子，且该左孩子有右孩子，则将该结点与该结点左孩子的所有右孩子连线。
> 2. 去线：去除所有结点与其右孩子的连线。
> 3. 旋转

* 二叉树转森林。 如果一颗二叉树的根结点有右孩子，那么就是森林，如果没有，那么就是树。
> 1. 从根结点开始，若右孩子存在，则把与右孩子结点的连线删除。从分离后的二叉树根结点看，如果右孩子存在，则连线删除。。。。。，直到所有右孩连线都删除为止，得到分离的二叉树。
> 2. 按上面的二叉树转树，将每棵分离后的二叉树转换为树即可


### 3.9 赫夫曼树 赫夫曼编码 ###
#### 赫夫曼编码 ####

3 7 9 11 24 50 

操作1：排序后，拿出最小的2个，相对小的作为左结点，相对大的作为右结点
> 10
>
> 3 7

把10，放入序列中，得到序列9 10 11 24 50 重复上面操作1
> 19
>
> 9 10

把19放入序列中，得到序列 11 19 24 50 重复上面操作1
> 30
>
>11 19

把30放入序列中，得到序列 24 30 50 重复上面操作1
> 54
> 
> 24 30

把54 放入序列中，得到序列 50 54， 重复上面操作1
> 104
> 
> 50 54

然后将上面的二叉树画出来就是赫夫曼树。。


#### 赫夫曼编码 ####
例如英文字母 A B C D E F。根据他们的出现频率不同，可以用赫夫曼树构造出每个字符的0，1编码，频率高的词编码短，频率低的词编码长一点。

